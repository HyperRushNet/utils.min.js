(function () {
  "use strict";

  const utils = {
    storage: {
      get(key, defaultValue = null) {
        try {
          const item = localStorage.getItem(key);
          return item === null ? defaultValue : JSON.parse(item);
        } catch {
          localStorage.removeItem(key);
          return defaultValue;
        }
      },
      set(key, value) {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
          throw new Error(`utils.storage.set failed for "${key}": ${e.message}`);
        }
      },
      remove(key) { localStorage.removeItem(key); },
      clear() { localStorage.clear(); }
    },

    geo: {
      getCurrent() {
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation) {
            return reject(new Error("Geolocation not supported"));
          }
          navigator.geolocation.getCurrentPosition(
            pos => {
              const { latitude: lat, longitude: lng, accuracy } = pos.coords;
              resolve({ lat, lng, accuracy });
            },
            err => {
              const messages = {
                [err.PERMISSION_DENIED]: "Location permission denied",
                [err.POSITION_UNAVAILABLE]: "Location unavailable",
                [err.TIMEOUT]: "Location request timeout"
              };
              reject(new Error(messages[err.code] || "Unknown geolocation error"));
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 600000 }
          );
        });
      }
    },

    dom: {
      createElement(tag, options = {}) {
        const el = document.createElement(tag);

        if (options.class ?? options.className) {
          const cls = options.class ?? options.className;
          typeof cls === "string" ? el.className = cls : el.classList.add(...cls);
        }

        if (options.text !== undefined) el.textContent = options.text;
        else if (options.html !== undefined) el.innerHTML = options.html;

        if (options.attrs) {
          Object.entries(options.attrs).forEach(([k, v]) => el.setAttribute(k, v));
        }

        if (options.on) {
          Object.entries(options.on).forEach(([event, handler]) => {
            const name = event.toLowerCase().replace(/^on/, "");
            el.addEventListener(name, handler);
          });
        }

        if (options.dataset) {
          Object.assign(el.dataset, options.dataset);
        }

        return el;
      }
    },

    perf: {
      measure(fn) {
        const start = performance.now();
        const result = fn();
        return result && typeof result.then === "function"
          ? result.then(() => performance.now() - start)
          : performance.now() - start;
      },
      debounce(fn, delay) {
        let tid;
        return (...args) => {
          clearTimeout(tid);
          tid = setTimeout(() => fn.apply(this, args), delay);
        };
      },
      throttle(fn, delay) {
        let last = 0;
        return (...args) => {
          const now = Date.now();
          if (now - last >= delay) {
            last = now;
            return fn.apply(this, args);
          }
        };
      }
    },

    id: (function () {
      let lastTime = 0;
      let seq = 0;
      return {
        create(prefix = "id") {
          let now = Date.now();
          if (now === lastTime) seq++;
          else { seq = 0; lastTime = now; }
          const rand = Math.random().toString(36).slice(2, 7);
          return `${prefix}-${now}-${seq}-${rand}`;
        }
      };
    })()
  };

  if (typeof window !== "undefined") {
    window.utils = utils;
  }

  if (typeof module !== "undefined" && module.exports) {
    module.exports = utils;
  }
})();
