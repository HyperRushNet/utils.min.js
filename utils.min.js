const utils = (() => {
  const storage = {
    get(t, o = null) {
      try {
        const r = localStorage.getItem(t);
        return r === null ? o : JSON.parse(r);
      } catch {
        localStorage.removeItem(t);
        return o;
      }
    },
    set(t, o) {
      try {
        localStorage.setItem(t, JSON.stringify(o));
      } catch (r) {
        throw new Error(`utils.storage.set failed: ${r.message}`);
      }
    },
    remove(t) {
      localStorage.removeItem(t);
    },
    clear() {
      localStorage.clear();
    }
  };

  const geo = {
    getCurrent: () => new Promise((resolve, reject) => {
      if (!navigator.geolocation) return reject(new Error("Geolocation not supported"));
      navigator.geolocation.getCurrentPosition(
        n => {
          const { latitude: lat, longitude: lng, accuracy } = n.coords;
          resolve({ lat, lng, accuracy });
        },
        n => {
          let msg = "Unknown geolocation error";
          if (n.code === n.PERMISSION_DENIED) msg = "Location permission denied";
          else if (n.code === n.POSITION_UNAVAILABLE) msg = "Location unavailable";
          else if (n.code === n.TIMEOUT) msg = "Location timeout";
          reject(new Error(msg));
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 600000 }
      );
    })
  };

  const dom = {
    createElement(tag, options = {}) {
      const el = document.createElement(tag);

      if (options.class || options.className) {
        const cls = options.class || options.className;
        if (Array.isArray(cls)) {
          el.classList.add(...cls);
        } else {
          el.className = cls;
        }
      }

      if (options.text !== undefined) el.textContent = options.text;
      else if (options.html !== undefined) el.innerHTML = options.html;

      if (options.attrs) {
        for (const [key, value] of Object.entries(options.attrs)) {
          el.setAttribute(key, value);
        }
      }

      if (options.on) {
        for (const [eventKey, handler] of Object.entries(options.on)) {
          const eventName = eventKey.toLowerCase().replace(/^on/, "");
          el.addEventListener(eventName, handler);
        }
      }

      if (options.dataset) {
        for (const [key, value] of Object.entries(options.dataset)) {
          el.dataset[key] = value;
        }
      }

      return el;
    }
  };

  const perf = {
    measure(fn) {
      const start = performance.now();
      const result = fn();
      if (result && typeof result.then === "function") {
        return result.then(() => performance.now() - start);
      }
      return performance.now() - start;
    },
    debounce(fn, delay) {
      let timer;
      return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    },
    throttle(fn, limit) {
      let last = 0;
      return function (...args) {
        const now = Date.now();
        if (now - last >= limit) {
          last = now;
          fn.apply(this, args);
        }
      };
    }
  };

  const id = (() => {
    let lastTime = 0;
    let counter = 0;
    return {
      create(prefix = "id") {
        let time = Date.now();
        if (time === lastTime) {
          counter++;
        } else {
          counter = 0;
          lastTime = time;
        }
        const random = Math.random().toString(36).substr(2, 5);
        return `${prefix}-${time}-${counter}-${random}`;
      }
    };
  })();

  return {
    storage,
    geo,
    dom,
    perf,
    id
  };
})();

if (typeof module !== "undefined" && module.exports) {
  module.exports = utils;
} else if (typeof window !== "undefined") {
  window.utils = utils;
}
